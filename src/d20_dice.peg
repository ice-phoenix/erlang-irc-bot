cmd <- space? (shuffle / deal / roll) space? tailer? `
    Tailer = lists:nth(4, Node),
    case Tailer of
        [] -> lists:nth(2, Node);
        _ -> {fail, tokens_left}
    end
`;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Deck control
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

shuffle <- "shuffle" `
    {deck, {shuffle}}
`;

deal <- "deal" space? natural? `
    Count = case lists:nth(3, Node) of
        [] -> 1;
        C -> C
    end,
    {deck, {deal, Count}}
`;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Rolling
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

roll <- "roll" space? (repeative / additive) `
    {roll, lists:nth(3, Node)}
`;

repeative <- natural repeat additive `
    [Count, _, Roll] = Node,
    {repeat, Count, Roll}
`;

additive <- multitive (plus / minus) additive / multitive `
    case Node of
        [Arg1, Op, Arg2] -> {Op, Arg1, Arg2};
        Arg -> Arg
    end
`;

multitive <- element times multitive / element `
    case Node of
        [Arg1, Op, Arg2] -> {Op, Arg1, Arg2};
        Arg -> Arg
    end
`;

element <- open_brace additive close_brace / item `
    case Node of
        [open_brace, Arg, close_brace] -> Arg;
        Arg -> Arg
    end
`;

item <- space? (savage_roll / roller / natural) space? `lists:nth(2, Node)`;

savage_roll <- savage natural `
    Roll = lists:nth(2, Node),
    {keep, 1, [{open_die, 1, 6}, {open_die, 1, Roll}]}
`;

roller <- natural? (die / open_die) natural (keep natural)? `
    Count = case lists:nth(1, Node) of
        [] -> 1;
        C -> C
    end,
    Type = lists:nth(2, Node),
    Faces = lists:nth(3, Node),
    case Node of
        [_, _, _, []] -> {keep, Count, [{Type, Count, Faces}]};
        [_, _, _, [keep, Keep]] -> {keep, Keep, [{Type, Count, Faces}]}
    end
`;

die <- "d" `die`;
open_die <- "D" `open_die`;
keep <- "k" `keep`;
savage <- "s" `savage`;

natural <- [0-9]+ `
    list_to_integer(lists:foldr(fun(E, Acc) -> binary_to_list(E) ++ Acc end, [], Node))
`;

plus <- "+" `plus`;
minus <- "-" `minus`;
times <- "*" `times`;
repeat <- "x" `repeat`;

open_brace <- space? "(" space? `open_brace`;
close_brace <- space? ")" space? `close_brace`;

space <- [ ]* `ignore`;

tailer <- .* ~;

`
-export([
    parse_and_process/2
]).

-define(MIN, 2).
-define(MAX, 100).
-define(DEAL_MAX, 10).

parse_and_process(String, State) ->
    Parsed = parse(String),
    case Parsed of
        {fail, Reason} -> {fail, Reason};
        {deck, Cmd} ->
            case deck(Cmd, State) of
                {fail, Reason} -> {fail, Reason};
                {ok, Results, NewState} -> {ok, {Results, NewState}}
            end;
        _ ->
            case roll(Parsed) of
                {fail, Reason} -> {fail, Reason};
                {ok, Results} -> {ok, {Results, State}}
            end
    end.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Decking
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

deck({shuffle}, State) ->
    {ok, ["shuffled the deck"], create_new_deck()};

deck({deal, Count}, State) when Count > ?DEAL_MAX ->
    {fail, deal_number_too_big};

deck({deal, Count}, State) ->
    {Cards, NewState} = case length(State) > Count of
        false -> {State, []};
        true -> lists:split(Count, State)
    end,
    Msg = case length(Cards) of
        0 -> ["dealt nothing (no cards left, please reshuffle)"];
        _ -> lists:map(fun(E) -> io_lib:format("dealt ~s", [E]) end, Cards)
    end,
    {ok, Msg, NewState}.

create_new_deck() ->
    Ranks = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "Jack", "Queen", "King", "Ace"],
    Suits = ["Clubs", "Diamonds", "Hearts", "Spades"],
    Cards = [ "[" ++ R ++ " of " ++ S ++ "]" || R <- Ranks, S <- Suits] ++ [ "[Red Jocker]", "[Black Jocker]" ],
    shuffle:shuffle(Cards).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Rolling
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

roll({roll, Tree}) ->
    try
        Rolls = roll_aux(Tree, []),
        Results = lists:map(
                    fun({Roll, Desc}) ->
                        io_lib:format("rolled ~B -> ~s", [Roll, Desc])
                    end,
                    Rolls),
        {ok, Results}
    catch
        throw:number_too_big ->
            {fail, number_too_big};
        throw:number_too_small ->
            {fail, number_too_small}
    end.

roll_aux({repeat, Count, Tree}, Acc) when Count > ?MAX ->
    throw(number_too_big);

roll_aux({repeat, Count, Tree}, Acc) when Count > 0 ->
    roll_aux({repeat, Count - 1, Tree}, Acc ++ process_tree(Tree));

roll_aux({repeat, Count, Tree}, Acc) ->
    Acc;

roll_aux(Tree, Acc) ->
    Acc ++ process_tree(Tree).

process_tree(Tree) ->
    [process_tree_aux(Tree)].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Die throwing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
throw_die(Faces) ->
    Roll = random:uniform(Faces),
    {Roll, pprint(Roll)}.

throw_open_die(Faces) ->
    throw_open_die_aux(Faces, []).

throw_open_die_aux(Faces, Rolls) ->
    Roll = random:uniform(Faces),
    Total = Rolls ++ [Roll],
    case Roll of
        Faces ->
            throw_open_die_aux(Faces, Total);
        _ ->
            case length(Total) of
                1 -> {lists:sum(Total), pprint(Total)};
                _ -> {lists:sum(Total), "{" ++ pprint(Total) ++ "}"}
            end
    end.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Check rolls for validity
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
process_tree_aux({die, Count, Faces}) when Count > ?MAX;
                                           Faces > ?MAX ->
    throw(number_too_big);

process_tree_aux({open_die, Count, Faces}) when Count > ?MAX;
                                                Faces > ?MAX ->
    throw(number_too_big);

process_tree_aux({die, Count, Faces}) when Faces < ?MIN ->
    throw(number_too_small);

process_tree_aux({open_die, Count, Faces}) when Faces < ?MIN ->
    throw(number_too_small);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Roll die tree
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
process_tree_aux({keep, Keep, Dice}) ->
    Results = lists:map(fun(Die) -> process_tree_aux(Die) end,
                        Dice),
    {R, Descs} = lists:unzip(Results),
    Rolls = lists:flatten(R),
    Count = length(Rolls),
    From = case Count > Keep of
        true -> Count - Keep + 1;
        false -> 1
    end,
    Sorted = lists:sort(Rolls),
    Kept = lists:sublist(Sorted, From, Keep),
    Result = lists:sum(Kept),
    {Result, pprint(Descs)};

process_tree_aux({Type, Count, Faces}) when Type == die;
                                            Type == open_die ->
    FaceList = lists:duplicate(Count, Faces),
    Rolls = case Type of
        die ->
            lists:map(fun(Face) -> throw_die(Face) end,
                      FaceList);
        open_die ->
            lists:map(fun(Face) -> throw_open_die(Face) end,
                      FaceList)
    end,
    {Results, Descs} = lists:unzip(Rolls),
    {Results, "[" ++ pprint(Descs) ++ "]"};

process_tree_aux(Number) when is_integer(Number) ->
    {Number, pprint(Number)};

process_tree_aux({plus, Arg1, Arg2}) ->
    {Res1, Desc1} = process_tree_aux(Arg1),
    {Res2, Desc2} = process_tree_aux(Arg2),
    {Res1 + Res2, "(" ++ Desc1 ++ " + " ++ Desc2 ++ ")"};

process_tree_aux({minus, Arg1, Arg2}) ->
    {Res1, Desc1} = process_tree_aux(Arg1),
    {Res2, Desc2} = process_tree_aux(Arg2),
    {Res1 - Res2, "(" ++ Desc1 ++ " - " ++ Desc2 ++ ")"};

process_tree_aux({times, Arg1, Arg2}) ->
    {Res1, Desc1} = process_tree_aux(Arg1),
    {Res2, Desc2} = process_tree_aux(Arg2),
    {Res1 * Res2, "(" ++ Desc1 ++ " * " ++ Desc2 ++ ")"}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Pprint the results
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
pprint(Term, Sep) ->
    pprint_aux(Term, "", Sep).

pprint(Term) ->
    pprint_aux(Term, "", ",").

pprint_aux(Number, Str, Sep) when is_integer(Number) ->
    Str ++ io_lib:format("~B", [Number]);

pprint_aux([Number], Str, Sep) when is_integer(Number) ->
    Str ++ io_lib:format("~B", [Number]);

pprint_aux([Number | T], Str, Sep) when is_integer(Number) ->
    pprint_aux(T, Str ++ io_lib:format("~B,", [Number]), Sep);

pprint_aux([Term], Str, Sep) ->
    Str ++ Term;

pprint_aux([], Str, Sep) ->
    Str;

pprint_aux([Term | T], Str, Sep) ->
    pprint_aux(T, Str ++ Term ++ Sep, Sep).
`

