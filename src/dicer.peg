%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Entry point
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

input <- cmd delimited_cmd* tailer? `
    [H, T, Tailer] = Node,
    case Tailer of
        [] -> lists:flatten([H] ++ T);
        _ -> throw({fail, tokens_left})
    end
`;

cmd <- space? (shuffle / deal / roll) space? silent? space? color? space? `
    Cmds = lists:nth(2, Node),
    Scope = case lists:nth(4, Node) of
        [] -> public;
        V -> V
    end,
    Color = case lists:nth(6, Node) of
        [] -> none;
        C -> C
    end,
    lists:map(
        fun(Cmd) ->
            case Cmd of
                #command{scope = none, color = none} ->
                    Cmd#command{scope = Scope, color = Color};
                #command{scope = none} ->
                    Cmd#command{scope = Scope};
                #command{color = none} ->
                    Cmd#command{color = Color};
                _ ->
                    Cmd
            end
        end,
        Cmds)
`;

delimited_cmd <- delim cmd `lists:nth(2, Node)`;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Deck control
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

shuffle <- "shuffle" `
    Step = #deck_cmd{tree = {shuffle}},
    [ #command{steps = [Step]} ]
`;

deal <- "deal" space? natural? `
    Count = case lists:nth(3, Node) of
        [] -> 1;
        C -> C
    end,
    Step = #deck_cmd{tree = {deal, Count}},
    [ #command{steps = [Step]} ]  
`;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Rolling
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

roll <- "roll" space? roll_desc space? delimited_roll_desc* `
	[_, _, H, _, T] = Node,
    [H] ++ T
`;

roll_desc <- (repeative / additive) color? `
    Roll = lists:nth(1, Node),
    Color = case lists:nth(2, Node) of
        [] -> none;
        C -> C
    end,
    Step = #roll_cmd{tree = Roll},
    #command{steps = [Step], color = Color}
`;

delimited_roll_desc <- delim roll_desc `lists:nth(2, Node)`;

repeative <- natural repeat additive `
    [Count, _, What] = Node,
    {repeat, Count, What}
`;

additive <- multitive (plus / minus) additive / multitive `
    case Node of
        [Arg1, Op, Arg2] -> {Op, Arg1, Arg2};
        Arg -> Arg
    end
`;

multitive <- element times multitive / element `
    case Node of
        [Arg1, Op, Arg2] -> {Op, Arg1, Arg2};
        Arg -> Arg
    end
`;

element <- open_brace additive close_brace / item `
    case Node of
        [open_brace, Arg, close_brace] -> Arg;
        Arg -> Arg
    end
`;

item <- space? (savage_roll / roller / natural) space? `lists:nth(2, Node)`;

savage_roll <- natural? savage natural `
    Times = case lists:nth(1, Node) of
        [] -> 1;
        T -> T
    end,
    Roll = lists:nth(3, Node),
    Dices = lists:duplicate(Times, {open_die, 1, Roll}),
    {keep, Times, [{wild_die, 1, 6}] ++ Dices}
`;

roller <- natural? (die / open_die) natural (keep natural)? `
    Count = case lists:nth(1, Node) of
        [] -> 1;
        C -> C
    end,
	[_, Type, Faces, _] = Node,
    case lists:nth(4, Node) of
        []           -> {sum, {keep, Count, [{Type, Count, Faces}]}};
        [keep, Keep] -> {sum, {keep, Keep, [{Type, Count, Faces}]}}
    end
`;

die <- "d" `die`;
open_die <- "D" `open_die`;
keep <- "k" `keep`;
savage <- "s" `savage`;

natural <- [0-9]+ `
    list_to_integer(lists:foldr(fun(E, Acc) -> binary_to_list(E) ++ Acc end, [], Node))
`;

plus <- "+" `plus`;
minus <- "-" `minus`;
times <- "*" `times`;
repeat <- "x" `repeat`;

open_brace <- space? "(" space? `open_brace`;
close_brace <- space? ")" space? `close_brace`;

space <- [ ]* `ignore`;

delim <- "," space? `ignore`;

silent <- "silent" `private`;

color <- (red /
          orange /
          yellow /
          green /
          teal /
          blue /
          purple /
          silver /
          black /
          white) ` Node `;

red    <- "red"    ` red `;
orange <- "orange" ` orange `;
yellow <- "yellow" ` yellow `;
green  <- "green"  ` green `;
teal   <- "teal"   ` teal `;
blue   <- "blue"   ` blue `;
purple <- "purple" ` purple `;
silver <- "silver" ` silver `;
black  <- "black"  ` black `;
white  <- "white"  ` white `;

tailer <- .* ~;

`
-export([
    parse_and_process/3
]).

-define(MIN, 2).
-define(MAX, 255).
-define(DEAL_MAX, 10).

-include("dicer_records.hrl").

parse_and_process(CmdString, Channel, State) ->
    try
        ChannelStates = State#dicer_state.channel_states,
        ChannelState = case orddict:find(Channel, ChannelStates) of
            error -> #channel_state{};
            {ok, Value} -> Value
        end,
        Cmds = case parse(CmdString) of
            {fail, _} -> throw({fail, parse_failed});
            C -> C
        end,
        {ok, {Results, NewChannelState}} = process_cmds(Cmds, ChannelState, []),
        NewChannelStates = orddict:store(Channel, NewChannelState, ChannelStates),
        {ok, {Results, State#dicer_state{channel_states = NewChannelStates}}}
    catch
        throw:{fail, Reason} -> {fail, Reason}
    end.

process_cmds([], ChannelState, Results) ->
    {ok, {lists:reverse(Results), ChannelState}};

process_cmds([Cmd | Rest], ChannelState, Results) ->
    {ok, {Rs, NewChannelState}} = process_single_cmd(Cmd, ChannelState),
    process_cmds(Rest, NewChannelState, Rs ++ Results).

process_single_cmd(Cmd, ChannelState) ->
    #command{steps = Steps, scope = Scope, color = Color} = Cmd,
    Scoper = fun(E) -> E#result{scope = Scope} end,
    Colorer = fun(E) -> E#result{color = Color} end,
    Mapper = fun(E) -> Scoper(Colorer(E)) end,
    {ok, {Results, NewChannelState}} = process_steps(Steps, ChannelState, []),
    {ok, {lists:map(Mapper, Results), NewChannelState}}.

process_steps([], ChannelState, Results) ->
    {ok, {Results, ChannelState}};

process_steps([Step | Rest], ChannelState, Results) ->
    {ok, {R, NewChannelState}} = process_single_step(Step, ChannelState),
    process_steps(Rest, NewChannelState, [R] ++ Results).

process_single_step(Step, ChannelState) ->
    case Step of
        #deck_cmd{tree = Tree} ->
            {ok, Result, NewChannelState} = deck(Tree, ChannelState),
            {ok, {Result, NewChannelState}};
        #roll_cmd{tree = Tree} ->
            {ok, Result} = roll(Tree),
            {ok, {Result, ChannelState}}
    end.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Decking
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

deck({shuffle}, State) ->
    {ok, #result{msgs = ["shuffled the deck"]}, State#channel_state{deck=create_new_deck()}};

deck({deal, Count}, State) when Count > ?DEAL_MAX ->
    throw({fail, deal_count_too_big});

deck({deal, Count}, State) ->
    {ok, Msgs, NewDeck} = deal_aux(Count, State#channel_state.deck, []),
    {ok, #result{msgs = Msgs}, State#channel_state{deck=NewDeck}};

deck(_Tree, _State) ->
    throw({fail, unsupported_deal_cmd}).

deal_aux(Count, Deck, Msgs) ->
    Length = length(Deck),
    {Cards, NewDeck} = case Length > Count of
        true -> lists:split(Count, Deck);
        false -> {Deck, []}
    end,
    NewMsgs = Msgs ++ lists:map(fun(E) -> io_lib:format("dealt ~s", [E]) end, Cards),
    case Length > Count of
        true -> {ok, NewMsgs, NewDeck};
        false -> deal_aux(Count - Length, create_new_deck(), NewMsgs ++ ["reshuffled the deck (no cards left)"])
    end.

create_new_deck() ->
    Ranks = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "Jack", "Queen", "King", "Ace"],
    Suits = ["Clubs", "Diamonds", "Hearts", "Spades"],
    Cards = [ "[" ++ R ++ " of " ++ S ++ "]" || R <- Ranks, S <- Suits] ++ [ "[Red Joker]", "[Black Joker]" ],
    shuffle:shuffle(Cards).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Rolling
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

roll(Tree) ->
    try
        Rolls = roll_aux(Tree, []),
        Msgs = case length(Rolls) > 1 of
            true ->
                {R, _} = lists:mapfoldl(
                            fun({Roll, Desc}, Idx) ->
                                {io_lib:format("rolled ~w -> ~s (roll #~w)", [Roll, Desc, Idx]), Idx + 1}
                            end,
                            1,
                            Rolls),
                R;
            false -> 
                [{Roll, Desc}] = Rolls,
                [ io_lib:format("rolled ~w -> ~s", [Roll, Desc]) ]
        end,
        {ok, #result{msgs = Msgs}}
    catch
        throw:number_too_big ->
            throw({fail, number_too_big});
        throw:number_too_small ->
            throw({fail, number_too_small});
        error:_ ->
            throw({fail, nested_error})
    end.

roll_aux({repeat, Count, Tree}, Acc) when Count > ?MAX ->
    throw(number_too_big);

roll_aux({repeat, Count, Tree}, Acc) when Count > 0 ->
    roll_aux({repeat, Count - 1, Tree}, process_tree(Tree) ++ Acc);

roll_aux({repeat, 0, Tree}, Acc) ->
    lists:reverse(Acc);

roll_aux(Tree, Acc) ->
    process_tree(Tree) ++ Acc.

process_tree(Tree) ->
    [process_tree_aux(Tree)].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Die throwing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

throw_die(Faces) ->
    Roll = random:uniform(Faces),
    {Roll, pprint(Roll)}.

throw_open_die(Faces) ->
    throw_open_die_aux(Faces, []).

throw_open_die_aux(Faces, Rolls) ->
    Roll = random:uniform(Faces),
    Total = [Roll] ++ Rolls,
    case Roll of
        Faces ->
            throw_open_die_aux(Faces, Total);
        _ ->
            Sum = lists:sum(Total),
            case length(Total) of
                1 -> {Sum, pprint(Sum)};
                _ -> {Sum, "{" ++ pprint(Sum) ++ "}"}
            end
    end.

throw_wild_die(Faces) ->
    {R, D} = throw_open_die(Faces),
    {R, D ++ "WD"}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Check rolls for validity
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

process_tree_aux({die, Count, Faces}) when Count > ?MAX;
                                           Faces > ?MAX ->
    throw(number_too_big);

process_tree_aux({open_die, Count, Faces}) when Count > ?MAX;
                                                Faces > ?MAX ->
    throw(number_too_big);

process_tree_aux({die, Count, Faces}) when Faces < ?MIN ->
    throw(number_too_small);

process_tree_aux({open_die, Count, Faces}) when Faces < ?MIN ->
    throw(number_too_small);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Roll die tree
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

process_tree_aux({sum, Rolls}) ->
    {R, D} = process_tree_aux(Rolls),
    {lists:sum(R), D};

process_tree_aux({keep, Keep, Dice}) ->
    Results = lists:flatmap(fun(Die) -> process_tree_aux(Die) end,
                            Dice),
    SortedResults = sort_rolls(Results),
    {Rolls, Descs} = lists:unzip(SortedResults),
    KeptRolls = lists:sublist(Rolls, 1, Keep),
    KeptDescs = lists:sublist(Descs, 1, Keep),
    RestDescs = lists:sublist(Descs, Keep + 1, ?MAX),
    case RestDescs of
        [] -> {KeptRolls, "[" ++ pprint(KeptDescs) ++ "]"};
        RD -> {KeptRolls, "[" ++ pprint(KeptDescs) ++ "] " ++ pprint(RestDescs)}
    end;

process_tree_aux({Type, Count, Faces}) when Type == die;
                                            Type == open_die;
                                            Type == wild_die ->
    FaceList = lists:duplicate(Count, Faces),
    Rolls = case Type of
        die ->      lists:map(fun(Face) -> throw_die(Face) end,      FaceList);
        open_die -> lists:map(fun(Face) -> throw_open_die(Face) end, FaceList);
        wild_die -> lists:map(fun(Face) -> throw_wild_die(Face) end, FaceList)
    end,
    sort_rolls(Rolls);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arithmetics
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

process_tree_aux(Number) when is_integer(Number) ->
    {Number, pprint(Number)};

process_tree_aux({plus, Arg1, Arg2}) ->
    {Res1, Desc1} = process_tree_aux(Arg1),
    {Res2, Desc2} = process_tree_aux(Arg2),
    {sum(Res1, Res2), "(" ++ Desc1 ++ " + " ++ Desc2 ++ ")"};

process_tree_aux({minus, Arg1, Arg2}) ->
    {Res1, Desc1} = process_tree_aux(Arg1),
    {Res2, Desc2} = process_tree_aux(Arg2),
    {sub(Res1, Res2), "(" ++ Desc1 ++ " - " ++ Desc2 ++ ")"};

process_tree_aux({times, Arg1, Arg2}) ->
    {Res1, Desc1} = process_tree_aux(Arg1),
    {Res2, Desc2} = process_tree_aux(Arg2),
    {mul(Res1, Res2), "(" ++ Desc1 ++ " * " ++ Desc2 ++ ")"}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Addition
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

sum(Arg1, Arg2) when is_list(Arg1), is_number(Arg2) ->
    lists:map(fun(A) -> A + Arg2 end, Arg1);

sum(Arg1, Arg2) when is_list(Arg2), is_number(Arg1) ->
    sum(Arg2, Arg1);

sum(Arg1, Arg2) when is_list(Arg1), is_list(Arg2) ->
    lists:zipwith(fun(A, B) -> A + B end, Arg1, Arg2);

sum(Arg1, Arg2) when is_number(Arg1), is_number(Arg2) ->
    Arg1 + Arg2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Subtraction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

sub(Arg1, Arg2) when is_list(Arg1), is_number(Arg2) ->
    lists:map(fun(A) -> A - Arg2 end, Arg1);

sub(Arg1, Arg2) when is_list(Arg2), is_number(Arg1) ->
    lists:map(fun(A) -> Arg1 - A end, Arg2);

sub(Arg1, Arg2) when is_list(Arg1), is_list(Arg2) ->
    lists:zipwith(fun(A, B) -> A - B end, Arg1, Arg2);

sub(Arg1, Arg2) when is_number(Arg1), is_number(Arg2) ->
    Arg1 - Arg2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Multiplication
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

mul(Arg1, Arg2) when is_list(Arg1), is_number(Arg2) ->
    lists:map(fun(A) -> A * Arg2 end, Arg1);

mul(Arg1, Arg2) when is_list(Arg2), is_number(Arg1) ->
    mul(Arg2, Arg1);

mul(Arg1, Arg2) when is_list(Arg1), is_list(Arg2) ->
    lists:zipwith(fun(A, B) -> A * B end, Arg1, Arg2);

mul(Arg1, Arg2) when is_number(Arg1), is_number(Arg2) ->
    Arg1 * Arg2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Pretty print the results
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

pprint(Term) ->
    pprint_aux(Term, "", ",").

pprint_aux(Number, Str, Sep) when is_integer(Number) ->
    Str ++ io_lib:format("~B", [Number]);

pprint_aux([Number], Str, Sep) when is_integer(Number) ->
    Str ++ io_lib:format("~B", [Number]);

pprint_aux([Number | T], Str, Sep) when is_integer(Number) ->
    pprint_aux(T, Str ++ io_lib:format("~B", [Number]) ++ Sep, Sep);

pprint_aux([Term], Str, Sep) ->
    Str ++ Term;

pprint_aux([Term | T], Str, Sep) ->
    pprint_aux(T, Str ++ Term ++ Sep, Sep);

pprint_aux([], Str, Sep) ->
    Str.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Sort rolls
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

sort_rolls(Rolls) when is_list(Rolls) ->
    lists:sort(
        fun({R1, D1}, {R2, D2}) -> R1 > R2 end,
        Rolls);

sort_rolls(Rolls) ->
    Rolls.
`
