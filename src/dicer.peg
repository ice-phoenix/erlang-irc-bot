cmd <- space? (shuffle / deal / roll) space? silent? tailer? `
    Visibility = case lists:nth(4, Node) of
        [] -> public;
        V -> V
    end,
    case lists:nth(5, Node) of
        [] -> {Visibility, lists:nth(2, Node)};
        _ -> throw({fail, tokens_left})
    end
`;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Deck control
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

shuffle <- "shuffle" `
    {deck, {shuffle}}
`;

deal <- "deal" space? natural? `
    Count = case lists:nth(3, Node) of
        [] -> 1;
        C -> C
    end,
    {deck, {deal, Count}}
`;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Rolling
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

roll <- "roll" space? (repeative / additive) `
    {roll, lists:nth(3, Node)}
`;

repeative <- natural repeat additive `
    [Count, _, Roll] = Node,
    {repeat, Count, Roll}
`;

additive <- multitive (plus / minus) additive / multitive `
    case Node of
        [Arg1, Op, Arg2] -> {Op, Arg1, Arg2};
        Arg -> Arg
    end
`;

multitive <- element times multitive / element `
    case Node of
        [Arg1, Op, Arg2] -> {Op, Arg1, Arg2};
        Arg -> Arg
    end
`;

element <- open_brace additive close_brace / item `
    case Node of
        [open_brace, Arg, close_brace] -> Arg;
        Arg -> Arg
    end
`;

item <- space? (savage_roll / roller / natural) space? `lists:nth(2, Node)`;

savage_roll <- natural? savage natural `
    Times = case lists:nth(1, Node) of
        [] -> 1;
        T -> T
    end,
    Roll = lists:nth(3, Node),
    Dices = lists:duplicate(Times, {open_die, 1, Roll}),
    {keep, Times, [{wild_die, 1, 6}] ++ Dices}
`;

roller <- natural? (die / open_die) natural (keep natural)? `
    Count = case lists:nth(1, Node) of
        [] -> 1;
        C -> C
    end,
    Type = lists:nth(2, Node),
    Faces = lists:nth(3, Node),
    case Node of
        [_, _, _, []] -> {sum, {keep, Count, [{Type, Count, Faces}]}};
        [_, _, _, [keep, Keep]] -> {sum, {keep, Keep, [{Type, Count, Faces}]}}
    end
`;

die <- "d" `die`;
open_die <- "D" `open_die`;
keep <- "k" `keep`;
savage <- "s" `savage`;

natural <- [0-9]+ `
    list_to_integer(lists:foldr(fun(E, Acc) -> binary_to_list(E) ++ Acc end, [], Node))
`;

plus <- "+" `plus`;
minus <- "-" `minus`;
times <- "*" `times`;
repeat <- "x" `repeat`;

open_brace <- space? "(" space? `open_brace`;
close_brace <- space? ")" space? `close_brace`;

space <- [ ]* `ignore`;

silent <- "silent" `private`;

tailer <- .* ~;

`
-export([
    parse_and_process/3
]).

-define(MIN, 2).
-define(MAX, 255).
-define(DEAL_MAX, 10).

-record(channel_state, {deck=[]}).

parse_and_process(CmdString, Channel, State) ->
    try
        {Visibility, What} = parse(CmdString),
        ChannelState = case orddict:find(Channel, State) of
            error -> #channel_state{};
            {ok, Value} -> Value
        end,
        Mapper = fun(Msg) -> {Visibility, Msg} end,
        case What of
            {deck, Cmd} ->
                {ok, Results, NewChannelState} = deck(Cmd, ChannelState),
                NewState = orddict:store(Channel, NewChannelState, State),
                {ok, {lists:map(Mapper, Results), NewState}};
            _ ->
                {ok, Results} = roll(What),
                {ok, {lists:map(Mapper, Results), State}}
        end
    catch
        throw:{fail, Reason} -> {fail, Reason}
    end.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Decking
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

deck({shuffle}, State) ->
    { ok, ["shuffled the deck"], State#channel_state{deck=create_new_deck()} };

deck({deal, Count}, State) when Count > ?DEAL_MAX ->
    throw({fail, deal_number_too_big});

deck({deal, Count}, State) ->
    {ok, Msgs, NewDeck} = deal_aux(Count, State#channel_state.deck, []),
    { ok, Msgs, State#channel_state{deck=NewDeck} }.

deal_aux(Count, Deck, Msg) ->
    Length = length(Deck),
    {Cards, NewDeck} = case Length > Count of
        false -> {Deck, []};
        true -> lists:split(Count, Deck)
    end,
    NewMsg = Msg ++ lists:map(fun(E) -> io_lib:format("dealt ~s", [E]) end, Cards),
    case Length > Count of
        false -> deal_aux(Count - Length, create_new_deck(), NewMsg ++ ["reshuffled the deck (no cards left)"]);
        true -> {ok, NewMsg, NewDeck}
    end.

create_new_deck() ->
    Ranks = ["2", "3", "4", "5", "6", "7", "8", "9", "10", "Jack", "Queen", "King", "Ace"],
    Suits = ["Clubs", "Diamonds", "Hearts", "Spades"],
    Cards = [ "[" ++ R ++ " of " ++ S ++ "]" || R <- Ranks, S <- Suits] ++ [ "[Red Jocker]", "[Black Jocker]" ],
    shuffle:shuffle(Cards).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Rolling
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

roll({roll, Tree}) ->
    try
        Rolls = roll_aux(Tree, []),
        Results = lists:map(
                    fun({Roll, Desc}) ->
                        io_lib:format("rolled ~w -> ~s", [Roll, Desc])
                    end,
                    Rolls),
        {ok, Results}
    catch
        throw:number_too_big ->
            throw({fail, number_too_big});
        throw:number_too_small ->
            throw({fail, number_too_small});
        error:_ ->
            throw({fail, nested_error})
    end.

roll_aux({repeat, Count, Tree}, Acc) when Count > ?MAX ->
    throw(number_too_big);

roll_aux({repeat, Count, Tree}, Acc) when Count > 0 ->
    roll_aux({repeat, Count - 1, Tree}, Acc ++ process_tree(Tree));

roll_aux({repeat, Count, Tree}, Acc) ->
    Acc;

roll_aux(Tree, Acc) ->
    Acc ++ process_tree(Tree).

process_tree(Tree) ->
    [process_tree_aux(Tree)].

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Die throwing
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
throw_die(Faces) ->
    Roll = random:uniform(Faces),
    {Roll, pprint(Roll)}.

throw_open_die(Faces) ->
    throw_open_die_aux(Faces, []).

throw_open_die_aux(Faces, Rolls) ->
    Roll = random:uniform(Faces),
    Total = Rolls ++ [Roll],
    case Roll of
        Faces ->
            throw_open_die_aux(Faces, Total);
        _ ->
            Sum = lists:sum(Total),
            case length(Total) of
                1 -> {Sum, pprint(Sum)};
                _ -> {Sum, "{" ++ pprint(Sum) ++ "}"}
            end
    end.

throw_wild_die(Faces) ->
    {R, D} = throw_open_die(Faces),
    {R, D ++ "*"}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Check rolls for validity
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
process_tree_aux({die, Count, Faces}) when Count > ?MAX;
                                           Faces > ?MAX ->
    throw(number_too_big);

process_tree_aux({open_die, Count, Faces}) when Count > ?MAX;
                                                Faces > ?MAX ->
    throw(number_too_big);

process_tree_aux({die, Count, Faces}) when Faces < ?MIN ->
    throw(number_too_small);

process_tree_aux({open_die, Count, Faces}) when Faces < ?MIN ->
    throw(number_too_small);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Roll die tree
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
process_tree_aux({sum, Rolls}) ->
    {R, D} = process_tree_aux(Rolls),
    {lists:sum(R), D};

process_tree_aux({keep, Keep, Dice}) ->
    Results = lists:flatmap(fun(Die) -> process_tree_aux(Die) end,
                            Dice),
    SortedResults = sort_rolls(Results),
    {R, D} = lists:unzip(SortedResults),
    {Rolls, Descs} = {R, D},
    KeptRolls = lists:sublist(Rolls, 1, Keep),
    KeptDescs = lists:sublist(Descs, 1, Keep),
    RestDescs = lists:sublist(Descs, Keep + 1, ?MAX),
    case RestDescs of
        [] -> {KeptRolls, "[" ++ pprint(KeptDescs) ++ "]"};
        RD -> {KeptRolls, "[" ++ pprint(KeptDescs) ++ "] " ++ pprint(RestDescs)}
    end;

process_tree_aux({Type, Count, Faces}) when Type == die;
                                            Type == open_die;
                                            Type == wild_die ->
    FaceList = lists:duplicate(Count, Faces),
    Rolls = case Type of
        die ->
            lists:map(fun(Face) -> throw_die(Face) end,
                      FaceList);
        open_die ->
            lists:map(fun(Face) -> throw_open_die(Face) end,
                      FaceList);
        wild_die ->
            lists:map(fun(Face) -> throw_wild_die(Face) end,
                      FaceList)
    end,
    SortedRolls = sort_rolls(Rolls),
    SortedRolls;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arithmetics
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
process_tree_aux(Number) when is_integer(Number) ->
    {Number, pprint(Number)};

process_tree_aux({plus, Arg1, Arg2}) ->
    {Res1, Desc1} = process_tree_aux(Arg1),
    {Res2, Desc2} = process_tree_aux(Arg2),
    {sum(Res1, Res2), "(" ++ Desc1 ++ " + " ++ Desc2 ++ ")"};

process_tree_aux({minus, Arg1, Arg2}) ->
    {Res1, Desc1} = process_tree_aux(Arg1),
    {Res2, Desc2} = process_tree_aux(Arg2),
    {sub(Res1, Res2), "(" ++ Desc1 ++ " - " ++ Desc2 ++ ")"};

process_tree_aux({times, Arg1, Arg2}) ->
    {Res1, Desc1} = process_tree_aux(Arg1),
    {Res2, Desc2} = process_tree_aux(Arg2),
    {mul(Res1, Res2), "(" ++ Desc1 ++ " * " ++ Desc2 ++ ")"}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Addition
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
sum(Arg1, Arg2) when is_list(Arg1), is_number(Arg2) ->
    lists:map(fun(A) -> A + Arg2 end, Arg1);

sum(Arg1, Arg2) when is_list(Arg2), is_number(Arg1) ->
    sum(Arg2, Arg1);

sum(Arg1, Arg2) when is_list(Arg1), is_list(Arg2) ->
    lists:zipwith(fun(A, B) -> A + B end, Arg1, Arg2);

sum(Arg1, Arg2) when is_number(Arg1), is_number(Arg2) ->
    Arg1 + Arg2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Subtraction
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
sub(Arg1, Arg2) when is_list(Arg1), is_number(Arg2) ->
    lists:map(fun(A) -> A - Arg2 end, Arg1);

sub(Arg1, Arg2) when is_list(Arg2), is_number(Arg1) ->
    sub(Arg2, Arg1);

sub(Arg1, Arg2) when is_list(Arg1), is_list(Arg2) ->
    lists:zipwith(fun(A, B) -> A - B end, Arg1, Arg2);

sub(Arg1, Arg2) when is_number(Arg1), is_number(Arg2) ->
    Arg1 - Arg2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Multiplication
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
mul(Arg1, Arg2) when is_list(Arg1), is_number(Arg2) ->
    lists:map(fun(A) -> A * Arg2 end, Arg1);

mul(Arg1, Arg2) when is_list(Arg2), is_number(Arg1) ->
    mul(Arg2, Arg1);

mul(Arg1, Arg2) when is_list(Arg1), is_list(Arg2) ->
    lists:zipwith(fun(A, B) -> A * B end, Arg1, Arg2);

mul(Arg1, Arg2) when is_number(Arg1), is_number(Arg2) ->
    Arg1 * Arg2.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Pprint the results
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
pprint(Term, Sep) ->
    pprint_aux(Term, "", Sep).

pprint(Term) ->
    pprint_aux(Term, "", ",").

pprint_aux(Number, Str, Sep) when is_integer(Number) ->
    Str ++ io_lib:format("~B", [Number]);

pprint_aux([Number], Str, Sep) when is_integer(Number) ->
    Str ++ io_lib:format("~B", [Number]);

pprint_aux([Number | T], Str, Sep) when is_integer(Number) ->
    pprint_aux(T, Str ++ io_lib:format("~B,", [Number]), Sep);

pprint_aux([Term], Str, Sep) ->
    Str ++ Term;

pprint_aux([], Str, Sep) ->
    Str;

pprint_aux([Term | T], Str, Sep) ->
    pprint_aux(T, Str ++ Term ++ Sep, Sep).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Sort rolls
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
sort_rolls(Rolls) when is_list(Rolls) ->
    lists:sort(
        fun({R1, D1}, {R2, D2}) -> R1 > R2 end,
        Rolls);

sort_rolls(Rolls) ->
    Rolls.
`

